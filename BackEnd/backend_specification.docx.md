# 

# **Стек технологий**

| Компонент | Технология |
| :---- | :---- |
| Фреймворк | FastAPI |
| База данных | PostgreSQL |
| ORM | SQLAlchemy 2.0 |
| Миграции | Alembic |
| Аутентификация | JWT (python-jose \+ passlib) |
| Валидация | Pydantic |
| Деплой | Docker \+ VPS |
| Push-уведомления | Firebase Cloud Messaging |
| Фоновые задачи | Celery \+ Redis |
| Файловое хранилище | S3 / MinIO |

# **1\) Аутентификация и регистрация**

## **Регистрация**

**Технологии:** FastAPI, Pydantic, passlib (bcrypt), python-jose (JWT), PostgreSQL

**Эндпоинт:** POST /auth/register

Пользователь отправляет email и password. Pydantic проверяет формат данных: email соответствует формату почты, password не пустой и соответствует требованиям. Если валидация не пройдена — возврат ошибки.

Сервер проверяет, существует ли пользователь с таким email в таблице users. Если существует — возврат ошибки "Email уже зарегистрирован".

Сервер хэширует пароль через bcrypt (односторонняя функция, обратное преобразование невозможно). Создаёт новую запись в таблице users. Генерирует access\_token и refresh\_token с user\_id нового пользователя. Возвращает токены клиенту.

## **Аутентификация**

**Технологии:** FastAPI, python-jose (JWT), passlib (bcrypt)

**Эндпоинты:** POST /auth/login, POST /auth/refresh, POST /auth/logout

Пользователь отправляет email и password. Сервер ищет пользователя в таблице users по email. Если не найден — ошибка.

Сервер сравнивает введенный пароль с сохраненным хэшем через bcrypt.verify. Если не совпадает — ошибка.

Если пароль верный, сервер создаёт два JWT-токена: access\_token (срок жизни 30 минут) и refresh\_token (срок жизни 7 дней, сохраняется в базе). Возвращает токены клиенту.

## **Восстановление пароля / почты**

**Технологии:** FastAPI, fastapi-mail, PostgreSQL

**Эндпоинты:** POST /auth/forgot-password, POST /auth/reset-password

Пользователь отправляет email на /auth/forgot-password. Сервер ищет пользователя по email. Если найден — генерирует случайный токен, сохраняет в таблицу password\_reset\_tokens (user\_id, token, срок действия, использован ли). Отправляет email со ссылкой, содержащей токен.

Пользователь переходит по ссылке, вводит новый пароль. Клиент отправляет токен и новый пароль на /auth/reset-password. Сервер проверяет: токен существует, не использован, не истёк. Если всё ок — хэширует новый пароль, обновляет password\_hash в таблице users, отмечает токен как использованный.

# **2\) Настройки**

## **Настройки push (включить / отключить)**

**Технологии:** PostgreSQL, SQLAlchemy

**Эндпоинт:** PUT /settings/notifications

Пользователь отправляет {"push\_enabled": true/false}. Сервер проверяет JWT, извлекает user\_id. Обновляет поле push\_enabled в таблице user\_settings. По сути — один UPDATE запрос, меняющий булево значение.

## **Настройки частоты уведомлений**

**Технологии:** PostgreSQL, SQLAlchemy, Celery

**Эндпоинт:** PUT /settings/notifications/frequency

Пользователь указывает список времён отправки (например, \[05:00, 12:00, 17:00\]) и частоту (ежедневно / еженедельно / выключено). Сервер сохраняет в таблицу user\_settings. Celery (фоновый планировщик) периодически читает эту таблицу и отправляет push в указанное время.

## **Удалить данные**

**Технологии:** PostgreSQL, SQLAlchemy

**Эндпоинты:** DELETE /account, DELETE /account/data

Hard delete (DELETE /account/data): сервер полностью удаляет пользователя и все связанные записи — цели, настройки, уведомления, достижения. CASCADE означает что при удалении пользователя автоматически удаляются все записи в других таблицах где есть его user\_id.

## **Поменять пароль**

**Технологии:** FastAPI, passlib (bcrypt), python-jose (JWT)

**Эндпоинт:** PUT /account/password

Пользователь отправляет текущий и новый пароль. Сервер проверяет JWT, сравнивает текущий пароль с хэшем в базе. Если совпал — хэширует новый пароль, обновляет password\_hash в таблице users.

Сервер генерирует новую пару токенов, перезаписывает refresh\_token в базе, возвращает новые токены клиенту. Старый refresh\_token автоматически становится недействительным.

# **3\) Экран цели**

## **Сохранение данных пользователя**

**Технологии:** PostgreSQL, SQLAlchemy

Данные пользователя сохраняются при регистрации в таблице users и обновляются через настройки. Связь с целями через user\_id (FK).

## **Хранение данных о текущих целях пользователя**

**Технологии:** PostgreSQL, SQLAlchemy

**Эндпоинт:** GET /goals

Сервер возвращает список целей пользователя из таблицы goals где is\_archived \= false. Каждая цель содержит: название, описание, дедлайн, прогресс в процентах.В зависимости от выполненных подзадач от самой задачи.

## **Хранение данных о целях в архиве**

**Эндпоинт:** GET /goals/archived

Используется та же таблица goals, фильтрация по is\_archived \= true. Архивация цели: PUT /goals/{id}/archive — сервер ставит is\_archived \= true.

## **Сохранение данных, связанных с целью**

**Эндпоинты:** POST /goals, PUT /goals/{id}

POST /goals — создать новую цель. Пользователь отправляет название, описание, дедлайн. Сервер создаёт запись в таблице goals.

PUT /goals/{id} — изменить цель. Сервер обновляет запись в goals.

Связанные данные (этапы, вложения) хранятся в отдельных таблицах, связаны с целью через goal\_id. Удалишь цель — удалятся и все связанные данные (CASCADE).

## **Прикрепить результат**

**Технологии:** PostgreSQL, S3/MinIO

**Эндпоинт:** POST /goals/{id}/attachments

Пользователь прикрепляет файл к цели — фото, скриншот, PDF. Сервер загружает файл в S3/MinIO (облачное хранилище), получает URL. В таблицу goal\_attachments записывается: goal\_id, file\_url (ссылка на файл), file\_type (тип), file\_name (название). Когда фронт показывает цель — подгружает файл по URL из базы.

## **Отметить выполненный этап**

**Технологии:** PostgreSQL, SQLAlchemy

**Эндпоинт:** PUT /goals/{goal\_id}/stages/{stage\_id}/complete

Пользователь нажимает галочку на этапе цели. Сервер обновляет запись в таблице goal\_stages: ставит is\_completed \= true и записывает текущее время. После этого пересчитывает прогресс цели — делит количество выполненных этапов на общее, обновляет поле progress в таблице goals. Если прогресс достиг определённого значения — проверяет достижения.

## **Изменить критерии у задачи**

Функционал отложен. Критерии избыточны — пользователь сам видит выполнил он цель или нет по отмеченным этапам. Дополнительная сущность усложняет интерфейс без явной пользы. Рассмотреть в будущих релизах если появится запрос от пользователей.

## **Синхронизация с AI(Deepseek)**

**Технологии:** OpenAI API, Celery

**Эндпоинт:** POST /goals/{id}/ai-sync

Пользователь создаёт цель и нажимает "Разбить на этапы с помощью AI". Сервер отправляет название и описание цели в Deepseek API. AI возвращает список этапов. Сервер сохраняет этапы в таблицу goal\_stages.

С Celery запрос уходит в фон, пользователь получает ответ "Этапы генерируются", через несколько секунд этапы появляются.

## **Уведомления о задачах**

**Технологии:** PostgreSQL, Celery, Firebase Cloud Messaging

Пользователь при создании задачи указывает время напоминания и частоту (каждый день, через день, каждые 3 дня). Сервер сохраняет в таблицу goal\_reminders: goal\_id, remind\_time, frequency\_days.

Celery периодически проверяет таблицу, если время и день совпали — отправляет push через Firebase. Напоминания продолжаются пока задача не выполнена или не достигнут дедлайн.

# **4\) Экран достижений**

## **Количественное соотношение процентов с пользователями**

**Технологии:** PostgreSQL, Redis

**Эндпоинт:** GET /achievements

Пользователь открывает экран достижений. Видит список всех достижений и у каждого процент — сколько пользователей его получили.

Сервер хранит достижения в таблице achievements (название, описание, иконка, условие получения). Связь пользователя с достижением — в таблице user\_achievements (кто и когда получил).

При запросе сервер считает: количество пользователей получивших достижение делит на общее количество пользователей, получает процент. Redis кэширует результат на день  — чтобы не считать заново при каждом запросе.

# **5\) Экран уведомлений**

## **Лента уведомленний**

**Технологии:** PostgreSQL, Firebase Cloud Messaging, Celery

**Эндпоинты:** GET /notifications, PUT /notifications/{id}/read, PUT /notifications/read-all

**Celery** — фреймворк для выполнения фоновых задач. Позволяет выносить долгие операции в отдельный процесс, не блокируя основной сервер.

**Firebase Cloud Messaging (FCM)** — сервис Google для доставки push-уведомлений на мобильные устройства. Выступает посредником между сервером и устройством пользователя.

Сервер хранит уведомления в таблице notifications. По запросу отдаёт список, отсортированный по дате, по 20 записей (пагинация). Обновляет статус is\_read при отметке прочитанным.

Когда происходит событие (достижение, напоминание) — сервер создаёт запись в таблице notifications. Celery в фоне отправляет запрос в Firebase, Firebase доставляет push на телефон.